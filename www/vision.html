<!--Themed-->
<p>The rise of computer networks is a driving force behind an evolution of computing based on communication, where the software and IT functionalities accessed by consumers are implemented as systems of inter-connected components that collaborate with each other. These components, called <strong>services</strong>, are deployed on infrastructures like the cloud, which enable developers to abstract considerably from the details of hardware support (like which computer is running which component).</p>
<p>From the point of view of developers and consumers, modern IT systems form what looks like a sea of services (depicted below).</p>
<p class="text-center">
<img src="imgs/coordmachine.png">
</p>
<p class="vision-quote">
«Modern IT systems form what looks like a sea of services»
</p>
<p>Services coordinate and use each other by means of exchanging messages over the network, requiring developers to think about aspects such as, but not limited to, data models, APIs, marshalling, coordination protocols, and workflows. Most mainstream programming languages have been designed to facilitate the programming of local computation, that is, computation that happens in the same computer. To be productive in the development of new services or the composition of existing ones, developers typically rely on additional libraries and frameworks, which offer their own additional abstractions. While this might look like an innocuous choice, one must be almost as careful in choosing a framework as with choosing a programming language: the abstractions offered by the framework will form the foundations of the design of the developed software. On the other hand, adding abstractions means increasing the load of knowledge that needs to be managed by the team, which must now be knowledgeable both about the used language (which moves slowly) and the used libraries and frameworks (which might move very fast, and sometimes one might also be tempted to change them).</p>
<p class="vision-quote">
«In service programming, mapping design to code is challenging»
</p>
<p>Our vision is to design a programming language with a different trade-off: instead of optimising for computation, the aim of Jolie is to offer native abstractions for the creation and composition of services.</p>
<p class="vision-quote">
«The aim of Jolie is to offer native abstractions for the creation and composition of services»
</p>
<p>By shifting the focus on services from libraries and frameworks to the programming language, we can change significantly how programmers manage their knowledge regarding service programming. The key idea is that the important abstractions for service programming should be crystallised in the programming language, translating to an easier learning curve for new service developers and less knowledge to be managed.</p>
